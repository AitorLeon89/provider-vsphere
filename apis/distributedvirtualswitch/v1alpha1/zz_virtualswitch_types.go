/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type HostObservation struct {
}

type HostParameters struct {

	// The list of NIC devices to map to uplinks on the VDS,
	// added in order they are specified.
	// Name of the physical NIC to be added to the proxy switch.
	// +kubebuilder:validation:Optional
	Devices []*string `json:"devices,omitempty" tf:"devices,omitempty"`

	// The host system ID of the host to add to the
	// VDS.
	// The managed object ID of the host this specification applies to.
	// +kubebuilder:validation:Required
	HostSystemID *string `json:"hostSystemId" tf:"host_system_id,omitempty"`
}

type PvlanMappingObservation struct {
}

type PvlanMappingParameters struct {

	// The primary VLAN ID. The VLAN IDs of 0 and
	// 4095 are reserved and cannot be used in this property.
	// The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.
	// +kubebuilder:validation:Required
	PrimaryVlanID *float64 `json:"primaryVlanId" tf:"primary_vlan_id,omitempty"`

	// The private VLAN type. Valid values are
	// promiscuous, community and isolated.
	// The private VLAN type. Valid values are promiscuous, community and isolated.
	// +kubebuilder:validation:Required
	PvlanType *string `json:"pvlanType" tf:"pvlan_type,omitempty"`

	// The secondary VLAN ID. The VLAN IDs of 0
	// and 4095 are reserved and cannot be used in this property.
	// The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.
	// +kubebuilder:validation:Required
	SecondaryVlanID *float64 `json:"secondaryVlanId" tf:"secondary_vlan_id,omitempty"`
}

type VirtualSwitchObservation struct {

	// : The current version of the VDS configuration, incremented
	// by subsequent updates to the VDS.
	// The version string of the configuration that this spec is trying to change.
	ConfigVersion *string `json:"configVersion,omitempty" tf:"config_version,omitempty"`

	// : The UUID of the created VDS.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type VirtualSwitchParameters struct {

	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// uplinks VDS argument. See
	// here for more details.
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	// +kubebuilder:validation:Optional
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	// +kubebuilder:validation:Optional
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	// +kubebuilder:validation:Optional
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	BackupnfcMaximumMbit *float64 `json:"backupnfcMaximumMbit,omitempty" tf:"backupnfc_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	BackupnfcReservationMbit *float64 `json:"backupnfcReservationMbit,omitempty" tf:"backupnfc_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	BackupnfcShareCount *float64 `json:"backupnfcShareCount,omitempty" tf:"backupnfc_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	BackupnfcShareLevel *string `json:"backupnfcShareLevel,omitempty" tf:"backupnfc_share_level,omitempty"`

	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	// Indicates whether to block all ports by default.
	// +kubebuilder:validation:Optional
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	// Enable beacon probing on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// The detailed contact information for the person
	// who is responsible for the VDS.
	// The contact detail for this DVS.
	// +kubebuilder:validation:Optional
	ContactDetail *string `json:"contactDetail,omitempty" tf:"contact_detail,omitempty"`

	// The name of the person who is responsible for the
	// VDS.
	// The contact name for this DVS.
	// +kubebuilder:validation:Optional
	ContactName *string `json:"contactName,omitempty" tf:"contact_name,omitempty"`

	// Map of custom attribute ids to attribute
	// value strings to set for VDS. See here
	// for a reference on how to set values for custom attributes.
	// A list of custom attributes to set on this resource.
	// +kubebuilder:validation:Optional
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// The ID of the datacenter where the VDS will be
	// created. Forces a new resource if changed.
	// The ID of the datacenter to create this virtual switch in.
	// +kubebuilder:validation:Required
	DatacenterID *string `json:"datacenterId" tf:"datacenter_id,omitempty"`

	// A detailed description for the VDS.
	// The description of the DVS.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// true if the traffic shaper is enabled
	// on the port for egress traffic.
	// True if the traffic shaper is enabled for egress traffic on the port.
	// +kubebuilder:validation:Optional
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	// +kubebuilder:validation:Optional
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	FaulttoleranceMaximumMbit *float64 `json:"faulttoleranceMaximumMbit,omitempty" tf:"faulttolerance_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	FaulttoleranceReservationMbit *float64 `json:"faulttoleranceReservationMbit,omitempty" tf:"faulttolerance_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	FaulttoleranceShareCount *float64 `json:"faulttoleranceShareCount,omitempty" tf:"faulttolerance_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	FaulttoleranceShareLevel *string `json:"faulttoleranceShareLevel,omitempty" tf:"faulttolerance_share_level,omitempty"`

	// The folder in which to create the VDS.
	// Forces a new resource if changed.
	// The folder to create this virtual switch in, relative to the datacenter.
	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	HbrMaximumMbit *float64 `json:"hbrMaximumMbit,omitempty" tf:"hbr_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	HbrReservationMbit *float64 `json:"hbrReservationMbit,omitempty" tf:"hbr_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	HbrShareCount *float64 `json:"hbrShareCount,omitempty" tf:"hbr_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	HbrShareLevel *string `json:"hbrShareLevel,omitempty" tf:"hbr_share_level,omitempty"`

	// Use the host block to declare a host specification. The
	// options are:
	// A host member specification.
	// +kubebuilder:validation:Optional
	Host []HostParameters `json:"host,omitempty" tf:"host,omitempty"`

	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments.
	// The IPv4 address of the switch. This can be used to see the DVS as a unique device with NetFlow.
	// +kubebuilder:validation:Optional
	IPv4Address *string `json:"ipv4Address,omitempty" tf:"ipv4_address,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ISCSIMaximumMbit *float64 `json:"iscsiMaximumMbit,omitempty" tf:"iscsi_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ISCSIReservationMbit *float64 `json:"iscsiReservationMbit,omitempty" tf:"iscsi_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	ISCSIShareCount *float64 `json:"iscsiShareCount,omitempty" tf:"iscsi_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	ISCSIShareLevel *string `json:"iscsiShareLevel,omitempty" tf:"iscsi_share_level,omitempty"`

	// Whether to ignore existing PVLAN
	// mappings not managed by this resource. Defaults to false.
	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	// +kubebuilder:validation:Optional
	IgnoreOtherPvlanMappings *bool `json:"ignoreOtherPvlanMappings,omitempty" tf:"ignore_other_pvlan_mappings,omitempty"`

	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// true if the traffic shaper is
	// enabled on the port for ingress traffic.
	// True if the traffic shaper is enabled for ingress traffic on the port.
	// +kubebuilder:validation:Optional
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// The Link Aggregation Control Protocol group
	// version to use with the VDS. Possible values are singleLag and
	// multipleLag.
	// The Link Aggregation Control Protocol group version in the switch. Can be one of singleLag or multipleLag.
	// +kubebuilder:validation:Optional
	LacpAPIVersion *string `json:"lacpApiVersion,omitempty" tf:"lacp_api_version,omitempty"`

	// Enables LACP for the ports that this policy
	// applies to.
	// Whether or not to enable LACP on all uplink ports.
	// +kubebuilder:validation:Optional
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The LACP mode. Can be one of active or passive.
	// The uplink LACP mode to use. Can be one of active or passive.
	// +kubebuilder:validation:Optional
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Whether to advertise or listen
	// for link discovery traffic.
	// Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.
	// +kubebuilder:validation:Optional
	LinkDiscoveryOperation *string `json:"linkDiscoveryOperation,omitempty" tf:"link_discovery_operation,omitempty"`

	// The discovery protocol type. Valid
	// types are cdp and lldp.
	// The discovery protocol type. Valid values are cdp and lldp.
	// +kubebuilder:validation:Optional
	LinkDiscoveryProtocol *string `json:"linkDiscoveryProtocol,omitempty" tf:"link_discovery_protocol,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ManagementMaximumMbit *float64 `json:"managementMaximumMbit,omitempty" tf:"management_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ManagementReservationMbit *float64 `json:"managementReservationMbit,omitempty" tf:"management_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the management traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	ManagementShareCount *float64 `json:"managementShareCount,omitempty" tf:"management_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	ManagementShareLevel *string `json:"managementShareLevel,omitempty" tf:"management_share_level,omitempty"`

	// The maximum transmission unit (MTU) for the VDS.
	// The maximum MTU on the switch.
	// +kubebuilder:validation:Optional
	MaxMtu *float64 `json:"maxMtu,omitempty" tf:"max_mtu,omitempty"`

	// The multicast filtering mode to use
	// with the VDS. Can be one of legacyFiltering or snooping.
	// The multicast filtering mode on the switch. Can be one of legacyFiltering, or snooping.
	// +kubebuilder:validation:Optional
	MulticastFilteringMode *string `json:"multicastFilteringMode,omitempty" tf:"multicast_filtering_mode,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	NFSMaximumMbit *float64 `json:"nfsMaximumMbit,omitempty" tf:"nfs_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	NFSReservationMbit *float64 `json:"nfsReservationMbit,omitempty" tf:"nfs_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	NFSShareCount *float64 `json:"nfsShareCount,omitempty" tf:"nfs_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	NFSShareLevel *string `json:"nfsShareLevel,omitempty" tf:"nfs_share_level,omitempty"`

	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// 60 to 3600. Default: 60.
	// The number of seconds after which active flows are forced to be exported to the collector.
	// +kubebuilder:validation:Optional
	NetflowActiveFlowTimeout *float64 `json:"netflowActiveFlowTimeout,omitempty" tf:"netflow_active_flow_timeout,omitempty"`

	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
	// Must be set before Netflow can be enabled.
	// IP address for the netflow collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed Switch Version 6.0 or later.
	// +kubebuilder:validation:Optional
	NetflowCollectorIPAddress *string `json:"netflowCollectorIpAddress,omitempty" tf:"netflow_collector_ip_address,omitempty"`

	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	// The port for the netflow collector.
	// +kubebuilder:validation:Optional
	NetflowCollectorPort *float64 `json:"netflowCollectorPort,omitempty" tf:"netflow_collector_port,omitempty"`

	// Enables Netflow on all ports that this policy
	// applies to.
	// Indicates whether to enable netflow on all ports.
	// +kubebuilder:validation:Optional
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is 10
	// to 600. Default: 15.
	// The number of seconds after which idle flows are forced to be exported to the collector.
	// +kubebuilder:validation:Optional
	NetflowIdleFlowTimeout *float64 `json:"netflowIdleFlowTimeout,omitempty" tf:"netflow_idle_flow_timeout,omitempty"`

	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: false.
	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	// +kubebuilder:validation:Optional
	NetflowInternalFlowsOnly *bool `json:"netflowInternalFlowsOnly,omitempty" tf:"netflow_internal_flows_only,omitempty"`

	// The observation domain ID for
	// the Netflow collector.
	// The observation Domain ID for the netflow collector.
	// +kubebuilder:validation:Optional
	NetflowObservationDomainID *float64 `json:"netflowObservationDomainId,omitempty" tf:"netflow_observation_domain_id,omitempty"`

	// The ratio of total number of packets to
	// the number of packets analyzed. The default is 0, which indicates that the
	// VDS should analyze all packets. The maximum value is 1000, which
	// indicates an analysis rate of 0.001%.
	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
	// +kubebuilder:validation:Optional
	NetflowSamplingRate *float64 `json:"netflowSamplingRate,omitempty" tf:"netflow_sampling_rate,omitempty"`

	// Set to true to enable
	// network I/O control. Default: false.
	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	// +kubebuilder:validation:Optional
	NetworkResourceControlEnabled *bool `json:"networkResourceControlEnabled,omitempty" tf:"network_resource_control_enabled,omitempty"`

	// The version of network I/O
	// control to use. Can be one of version2 or version3. Default: version2.
	// The network I/O control version to use. Can be one of version2 or version3.
	// +kubebuilder:validation:Optional
	NetworkResourceControlVersion *string `json:"networkResourceControlVersion,omitempty" tf:"network_resource_control_version,omitempty"`

	// If true, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	// +kubebuilder:validation:Optional
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// Used to define a secondary VLAN
	// ID when using private VLANs.
	// The secondary VLAN ID for this port.
	// +kubebuilder:validation:Optional
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// Use the pvlan_mapping block to declare a
	// private VLAN mapping. The options are:
	// A private VLAN (PVLAN) mapping.
	// +kubebuilder:validation:Optional
	PvlanMapping []PvlanMappingParameters `json:"pvlanMapping,omitempty" tf:"pvlan_mapping,omitempty"`

	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// uplinks VDS argument. See
	// here for more details.
	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// The IDs of any tags to attach to this resource. See
	// here for a reference on how to apply tags.
	// A list of tag IDs to apply to this object.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The uplink teaming policy. Can be one of
	// loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	// +kubebuilder:validation:Optional
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// Forward all traffic transmitted by ports for which
	// this policy applies to its VDS uplinks.
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	// +kubebuilder:validation:Optional
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// A list of strings that uniquely identifies the names
	// of the uplinks on the VDS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the VDS, in addition to the
	// names. See here for an example on how to
	// use this option.
	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
	// +kubebuilder:validation:Optional
	Uplinks []*string `json:"uplinks,omitempty" tf:"uplinks,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VdpMaximumMbit *float64 `json:"vdpMaximumMbit,omitempty" tf:"vdp_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VdpReservationMbit *float64 `json:"vdpReservationMbit,omitempty" tf:"vdp_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VdpShareCount *float64 `json:"vdpShareCount,omitempty" tf:"vdp_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VdpShareLevel *string `json:"vdpShareLevel,omitempty" tf:"vdp_share_level,omitempty"`

	// - The version of the VDS. BY default, a VDS is created
	// at the latest version supported by the vSphere version if not specified.
	// A VDS can be upgraded to a newer version, but can not be downgraded.
	// The version of this virtual switch. Allowed versions are 8.0.0, 7.0.3, 7.0.2, 7.0.0, 6.6.0, 6.5.0, 6.0.0, 5.5.0, 5.1.0, and 5.0.0.
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VirtualmachineMaximumMbit *float64 `json:"virtualmachineMaximumMbit,omitempty" tf:"virtualmachine_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VirtualmachineReservationMbit *float64 `json:"virtualmachineReservationMbit,omitempty" tf:"virtualmachine_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VirtualmachineShareCount *float64 `json:"virtualmachineShareCount,omitempty" tf:"virtualmachine_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VirtualmachineShareLevel *string `json:"virtualmachineShareLevel,omitempty" tf:"virtualmachine_share_level,omitempty"`

	// : The UUID of the created VDS.
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// Used to denote VLAN trunking. Use the min_vlan
	// and max_vlan sub-arguments to define the tagged VLAN range. Multiple
	// vlan_range definitions are allowed, but they must not overlap. Example
	// below:
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanRange []VlanRangeParameters `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VmotionMaximumMbit *float64 `json:"vmotionMaximumMbit,omitempty" tf:"vmotion_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VmotionReservationMbit *float64 `json:"vmotionReservationMbit,omitempty" tf:"vmotion_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VmotionShareCount *float64 `json:"vmotionShareCount,omitempty" tf:"vmotion_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VmotionShareLevel *string `json:"vmotionShareLevel,omitempty" tf:"vmotion_share_level,omitempty"`

	// The maximum amount of bandwidth allowed for this
	// traffic class in Mbits/sec.
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VsanMaximumMbit *float64 `json:"vsanMaximumMbit,omitempty" tf:"vsan_maximum_mbit,omitempty"`

	// The guaranteed amount of bandwidth for this
	// traffic class in Mbits/sec.
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VsanReservationMbit *float64 `json:"vsanReservationMbit,omitempty" tf:"vsan_reservation_mbit,omitempty"`

	// The number of shares for a custom level. This is
	// ignored if share_level is not custom.
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VsanShareCount *float64 `json:"vsanShareCount,omitempty" tf:"vsan_share_count,omitempty"`

	// A pre-defined share level that can be assigned to
	// this resource class. Can be one of low, normal, high, or custom.
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VsanShareLevel *string `json:"vsanShareLevel,omitempty" tf:"vsan_share_level,omitempty"`
}

type VlanRangeObservation struct {
}

type VlanRangeParameters struct {

	// The member VLAN for the ports this policy applies to. A
	// value of 0 means no VLAN.
	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Required
	MaxVlan *float64 `json:"maxVlan" tf:"max_vlan,omitempty"`

	// The member VLAN for the ports this policy applies to. A
	// value of 0 means no VLAN.
	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Required
	MinVlan *float64 `json:"minVlan" tf:"min_vlan,omitempty"`
}

// VirtualSwitchSpec defines the desired state of VirtualSwitch
type VirtualSwitchSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VirtualSwitchParameters `json:"forProvider"`
}

// VirtualSwitchStatus defines the observed state of VirtualSwitch.
type VirtualSwitchStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VirtualSwitchObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualSwitch is the Schema for the VirtualSwitchs API. Provides a vSphere Distributed Switch resource. This can be used to create and manage the vSphere Distributed Switch resources in vCenter Server.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vsphere}
type VirtualSwitch struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualSwitchSpec   `json:"spec"`
	Status            VirtualSwitchStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualSwitchList contains a list of VirtualSwitchs
type VirtualSwitchList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualSwitch `json:"items"`
}

// Repository type metadata.
var (
	VirtualSwitch_Kind             = "VirtualSwitch"
	VirtualSwitch_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VirtualSwitch_Kind}.String()
	VirtualSwitch_KindAPIVersion   = VirtualSwitch_Kind + "." + CRDGroupVersion.String()
	VirtualSwitch_GroupVersionKind = CRDGroupVersion.WithKind(VirtualSwitch_Kind)
)

func init() {
	SchemeBuilder.Register(&VirtualSwitch{}, &VirtualSwitchList{})
}
